# 3D模型生成效果评估系统设计方案

## 1. 系统概述

本评估系统专门针对3D模型生成效果进行多维度质量评估，通过自动化算法和用户反馈相结合的方式，为模型生成质量提供客观、准确的评分。

## 2. 评估指标体系

### 2.1 几何质量评估 (权重: 40%)

#### 2.1.1 网格完整性检测
```python
class MeshIntegrityEvaluator:
    def evaluate(self, mesh):
        score = 100
        
        # 检测破洞
        holes = self.detect_holes(mesh)
        score -= len(holes) * 5
        
        # 检测非流形边
        non_manifold_edges = self.detect_non_manifold_edges(mesh)
        score -= len(non_manifold_edges) * 3
        
        # 检测重复顶点
        duplicate_vertices = self.detect_duplicate_vertices(mesh)
        score -= len(duplicate_vertices) * 2
        
        return max(0, score)
```

#### 2.1.2 拓扑结构验证
- **欧拉特征数**: V - E + F = 2 (对于封闭网格)
- **边界检测**: 识别开放边界
- **连通性分析**: 检测独立组件数量

#### 2.1.3 几何精度评估
```python
class GeometricAccuracyEvaluator:
    def evaluate(self, generated_mesh, reference_description):
        # 尺寸匹配度
        size_accuracy = self.evaluate_size_match(generated_mesh, reference_description)
        
        # 形状相似度
        shape_similarity = self.evaluate_shape_similarity(generated_mesh, reference_description)
        
        # 比例协调性
        proportion_harmony = self.evaluate_proportions(generated_mesh)
        
        return (size_accuracy * 0.4 + shape_similarity * 0.4 + proportion_harmony * 0.2)
```

### 2.2 视觉效果评估 (权重: 35%)

#### 2.2.1 渲染质量评估
```python
class RenderQualityEvaluator:
    def evaluate(self, model_path):
        # 生成多角度渲染图
        render_images = self.generate_renders(model_path, angles=[0, 45, 90, 135, 180])
        
        scores = []
        for image in render_images:
            # 图像清晰度
            sharpness = self.calculate_sharpness(image)
            
            # 光照合理性
            lighting_quality = self.evaluate_lighting(image)
            
            # 阴影效果
            shadow_quality = self.evaluate_shadows(image)
            
            scores.append((sharpness + lighting_quality + shadow_quality) / 3)
        
        return sum(scores) / len(scores)
```

#### 2.2.2 色彩准确性评估
- **色彩匹配度**: 与文本描述的色彩对比
- **色彩和谐度**: 配色方案的协调性
- **饱和度适宜性**: 色彩饱和度的合理性

#### 2.2.3 风格一致性评估
```python
class StyleConsistencyEvaluator:
    def __init__(self):
        self.style_classifiers = {
            'realistic': RealisticStyleClassifier(),
            'cartoon': CartoonStyleClassifier(),
            'minimalist': MinimalistStyleClassifier(),
            'futuristic': FuturisticStyleClassifier()
        }
    
    def evaluate(self, model, target_style):
        classifier = self.style_classifiers[target_style]
        confidence = classifier.predict_confidence(model)
        return confidence * 100
```

### 2.3 技术指标评估 (权重: 25%)

#### 2.3.1 性能指标
```python
class PerformanceEvaluator:
    def evaluate(self, model_info):
        score = 100
        
        # 文件大小评估 (理想范围: 1-10MB)
        file_size_mb = model_info['file_size'] / (1024 * 1024)
        if file_size_mb > 10:
            score -= (file_size_mb - 10) * 2
        elif file_size_mb < 0.1:
            score -= 20  # 过小可能质量不足
        
        # 面数评估 (理想范围: 1K-50K)
        face_count = model_info['face_count']
        if face_count > 50000:
            score -= (face_count - 50000) / 1000
        elif face_count < 100:
            score -= 30  # 面数过少
        
        # 生成时间评估 (理想: <60秒)
        generation_time = model_info['generation_time']
        if generation_time > 60:
            score -= (generation_time - 60) * 0.5
        
        return max(0, score)
```

## 3. 用户反馈系统

### 3.1 评分机制
```sql
CREATE TABLE `model_user_ratings` (
  `id` BIGINT AUTO_INCREMENT PRIMARY KEY,
  `model_id` VARCHAR(64) NOT NULL,
  `user_id` BIGINT NOT NULL,
  `overall_rating` DECIMAL(3,2) NOT NULL COMMENT '总体评分(1-5)',
  `quality_rating` DECIMAL(3,2) COMMENT '质量评分(1-5)',
  `accuracy_rating` DECIMAL(3,2) COMMENT '准确性评分(1-5)',
  `visual_rating` DECIMAL(3,2) COMMENT '视觉效果评分(1-5)',
  `feedback_text` TEXT COMMENT '文字反馈',
  `created_at` DATETIME DEFAULT CURRENT_TIMESTAMP,
  
  UNIQUE KEY `uk_model_user` (`model_id`, `user_id`),
  INDEX `idx_model_id` (`model_id`),
  INDEX `idx_overall_rating` (`overall_rating`)
);
```

### 3.2 反馈收集API
```java
@RestController
@RequestMapping("/api/evaluation")
public class ModelEvaluationController {
    
    @PostMapping("/rate/{modelId}")
    public ResponseEntity<String> rateModel(
            @PathVariable String modelId,
            @RequestBody ModelRatingRequest request) {
        
        // 保存用户评分
        modelRatingService.saveRating(modelId, request);
        
        // 更新模型平均评分
        modelService.updateAverageRating(modelId);
        
        return ResponseEntity.ok("评分提交成功");
    }
    
    @GetMapping("/stats/{modelId}")
    public ResponseEntity<ModelEvaluationStats> getEvaluationStats(
            @PathVariable String modelId) {
        
        ModelEvaluationStats stats = evaluationService.getStats(modelId);
        return ResponseEntity.ok(stats);
    }
}
```

## 4. 综合评分算法

### 4.1 加权评分计算
```python
class ComprehensiveEvaluator:
    def __init__(self):
        self.weights = {
            'geometric_quality': 0.40,
            'visual_effect': 0.35,
            'technical_metrics': 0.25
        }
    
    def calculate_final_score(self, evaluations):
        final_score = 0
        
        for category, weight in self.weights.items():
            category_score = evaluations[category]
            final_score += category_score * weight
        
        # 用户反馈调整 (±10%)
        user_feedback_adjustment = self.calculate_user_feedback_adjustment(
            evaluations.get('user_ratings', [])
        )
        
        final_score = final_score * (1 + user_feedback_adjustment)
        
        return min(100, max(0, final_score))
    
    def calculate_user_feedback_adjustment(self, user_ratings):
        if not user_ratings:
            return 0
        
        avg_rating = sum(user_ratings) / len(user_ratings)
        # 将1-5分转换为-0.1到+0.1的调整系数
        return (avg_rating - 3) * 0.033
```

### 4.2 评分等级划分
```python
class ScoreGrading:
    @staticmethod
    def get_grade(score):
        if score >= 90:
            return {'grade': 'A+', 'description': '优秀', 'color': '#00C851'}
        elif score >= 80:
            return {'grade': 'A', 'description': '良好', 'color': '#39C0ED'}
        elif score >= 70:
            return {'grade': 'B', 'description': '中等', 'color': '#ffbb33'}
        elif score >= 60:
            return {'grade': 'C', 'description': '及格', 'color': '#FF8800'}
        else:
            return {'grade': 'D', 'description': '不及格', 'color': '#FF4444'}
```

## 5. 实时监控面板

### 5.1 评估数据统计
```sql
-- 模型质量统计视图
CREATE VIEW `model_quality_stats` AS
SELECT 
    m.model_id,
    m.name,
    m.category,
    m.created_at,
    COALESCE(e.geometric_score, 0) as geometric_score,
    COALESCE(e.visual_score, 0) as visual_score,
    COALESCE(e.technical_score, 0) as technical_score,
    COALESCE(e.final_score, 0) as final_score,
    COALESCE(AVG(r.overall_rating), 0) as user_rating,
    COUNT(r.id) as rating_count
FROM t_model m
LEFT JOIN model_evaluations e ON m.model_id = e.model_id
LEFT JOIN model_user_ratings r ON m.model_id = r.model_id
GROUP BY m.model_id;
```

### 5.2 质量趋势分析
```python
class QualityTrendAnalyzer:
    def analyze_daily_trends(self, days=30):
        """分析最近N天的质量趋势"""
        query = """
        SELECT 
            DATE(created_at) as date,
            AVG(final_score) as avg_score,
            COUNT(*) as model_count,
            AVG(geometric_score) as avg_geometric,
            AVG(visual_score) as avg_visual,
            AVG(technical_score) as avg_technical
        FROM model_evaluations 
        WHERE created_at >= DATE_SUB(NOW(), INTERVAL %s DAY)
        GROUP BY DATE(created_at)
        ORDER BY date
        """
        return self.db.execute(query, [days])
    
    def identify_quality_issues(self):
        """识别质量问题模式"""
        issues = []
        
        # 几何质量问题
        low_geometric = self.db.execute("""
            SELECT model_id, geometric_score 
            FROM model_evaluations 
            WHERE geometric_score < 60
        """)
        
        if low_geometric:
            issues.append({
                'type': 'geometric_quality',
                'count': len(low_geometric),
                'description': '几何质量偏低的模型数量较多'
            })
        
        return issues
```

## 6. API接口设计

### 6.1 评估触发接口
```java
@PostMapping("/evaluate/{modelId}")
public ResponseEntity<EvaluationResult> evaluateModel(@PathVariable String modelId) {
    try {
        // 异步启动评估任务
        String taskId = evaluationService.startEvaluation(modelId);
        
        return ResponseEntity.ok(EvaluationResult.builder()
            .taskId(taskId)
            .status("processing")
            .message("评估任务已启动")
            .build());
            
    } catch (Exception e) {
        return ResponseEntity.status(500)
            .body(EvaluationResult.error("评估启动失败: " + e.getMessage()));
    }
}
```

### 6.2 评估结果查询接口
```java
@GetMapping("/result/{taskId}")
public ResponseEntity<EvaluationDetail> getEvaluationResult(@PathVariable String taskId) {
    EvaluationDetail result = evaluationService.getResult(taskId);
    
    if (result == null) {
        return ResponseEntity.notFound().build();
    }
    
    return ResponseEntity.ok(result);
}
```

## 7. 部署和集成

### 7.1 Docker容器化
```dockerfile
FROM python:3.9-slim

WORKDIR /app

# 安装3D处理库
RUN pip install trimesh open3d numpy scipy scikit-image

# 复制评估代码
COPY evaluation/ ./evaluation/
COPY requirements.txt .

RUN pip install -r requirements.txt

EXPOSE 8080

CMD ["python", "evaluation/server.py"]
```

### 7.2 与现有系统集成
```java
@Component
public class ModelEvaluationIntegration {
    
    @EventListener
    public void onModelGenerated(ModelGeneratedEvent event) {
        // 模型生成完成后自动触发评估
        String modelId = event.getModelId();
        evaluationService.scheduleEvaluation(modelId);
    }
    
    @Scheduled(fixedRate = 3600000) // 每小时执行一次
    public void batchEvaluateModels() {
        // 批量评估未评估的模型
        List<String> unevaluatedModels = modelService.getUnevaluatedModels();
        for (String modelId : unevaluatedModels) {
            evaluationService.scheduleEvaluation(modelId);
        }
    }
}
```

## 8. 性能优化

### 8.1 缓存策略
```python
class EvaluationCache:
    def __init__(self):
        self.redis_client = redis.Redis(host='localhost', port=6379, db=0)
    
    def get_cached_result(self, model_id, version):
        cache_key = f"evaluation:{model_id}:{version}"
        cached = self.redis_client.get(cache_key)
        
        if cached:
            return json.loads(cached)
        return None
    
    def cache_result(self, model_id, version, result, ttl=86400):
        cache_key = f"evaluation:{model_id}:{version}"
        self.redis_client.setex(
            cache_key, 
            ttl, 
            json.dumps(result)
        )
```

### 8.2 并行处理
```python
from concurrent.futures import ThreadPoolExecutor
import asyncio

class ParallelEvaluator:
    def __init__(self, max_workers=4):
        self.executor = ThreadPoolExecutor(max_workers=max_workers)
    
    async def evaluate_batch(self, model_ids):
        tasks = []
        for model_id in model_ids:
            task = asyncio.create_task(self.evaluate_single(model_id))
            tasks.append(task)
        
        results = await asyncio.gather(*tasks)
        return results
    
    async def evaluate_single(self, model_id):
        loop = asyncio.get_event_loop()
        result = await loop.run_in_executor(
            self.executor, 
            self._sync_evaluate, 
            model_id
        )
        return result
```

## 9. 监控和告警

### 9.1 质量告警规则
```python
class QualityAlertSystem:
    def __init__(self):
        self.alert_rules = [
            {
                'name': '几何质量过低',
                'condition': lambda score: score['geometric_score'] < 50,
                'severity': 'high'
            },
            {
                'name': '用户评分下降',
                'condition': lambda score: score['user_rating'] < 2.0,
                'severity': 'medium'
            },
            {
                'name': '生成时间过长',
                'condition': lambda score: score['generation_time'] > 120,
                'severity': 'low'
            }
        ]
    
    def check_alerts(self, evaluation_result):
        alerts = []
        for rule in self.alert_rules:
            if rule['condition'](evaluation_result):
                alerts.append({
                    'rule': rule['name'],
                    'severity': rule['severity'],
                    'model_id': evaluation_result['model_id'],
                    'timestamp': datetime.now()
                })
        return alerts
```

## 10. 总结

本评估系统通过多维度的自动化算法和用户反馈相结合，能够全面、客观地评估3D模型生成效果。系统具有以下特点：

- **全面性**: 覆盖几何、视觉、技术三大维度
- **自动化**: 减少人工干预，提高评估效率
- **可扩展**: 支持新的评估算法和指标
- **实时性**: 提供实时监控和告警功能
- **用户友好**: 直观的评分展示和反馈机制

通过这套评估系统，可以持续监控和改进3D模型生成的质量，为用户提供更好的服务体验。